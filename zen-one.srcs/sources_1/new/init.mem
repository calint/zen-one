// addi 1 r15
F013 // [0] 1:1
// led r15
F733 // [1] 2:1
// xor r15 r15          # zero r15
FF63 // [2] 3:1
// loop:
//     ldi hello.len r2 # hello
2033 // [3] 5:5
0096 // [4] 5:5
//     ld r2 r2         # load len
2253 // [5] 6:5
//     ldi hello.buf r1 # buffer 
1033 // [6] 7:5
0097 // [7] 7:5
//     call print       #
005B // [8] 8:5
//     
//     addi 1 r15
F013 // [9] 10:5
//     cp r15 r1        # print r15 as hex
1FC3 // [10] 11:5
//     call print_hex   #
006B // [11] 12:5
//     ldi 0x20 r1      # space
1033 // [12] 13:5
0020 // [13] 13:5
//     wl r1            #
1233 // [14] 14:5
//     
//     ldi input.buf r1 # input buffer
1033 // [15] 16:5
009B // [16] 16:5
//     ldi input.len r2 # buffer size address
2033 // [17] 17:5
009A // [18] 17:5
//     ld r2 r2         # buffer size
2253 // [19] 18:5
//     call input       # input (buffer:r1, buflen:r2)
002B // [20] 19:5
//     ldi 0xa r3       # new line
3033 // [21] 20:5
000A // [22] 20:5
//     wl r3            #  send
3233 // [23] 21:5
//     call print       # print (buffer:r1, buflen:r2) 'input' sets buflen 
005B // [24] 22:5
//     ldi 0xa r3       # new line
3033 // [25] 23:5
000A // [26] 23:5
//     wl r3            #  send
3233 // [27] 24:5
//     jmp loop
FE7F // [28] 25:5
0000
0000
0000
// 
// input: func # r1: bufptr, r2: buflen  clobbers: r2, r3, r4, r5, r6, r7, r8, r9, r10
//     ldi 0x000d r3
3033 // [32] 28:5
000D // [33] 28:5
//     ldi 0x0d00 r4
4033 // [34] 29:5
0D00 // [35] 29:5
//     ldi 0x00ff r5
5033 // [36] 30:5
00FF // [37] 30:5
//     ldi 0xff00 r6
6033 // [38] 31:5
FF00 // [39] 31:5
//     cp r1 r10
A1C3 // [40] 32:5
//     xor r9 r9
9963 // [41] 33:5
//     loop:
//         # read the low byte
//         rl r7        # read into lower r7
7633 // [42] 36:9
//         wl r7        # echo
7233 // [43] 37:9
//         addi 1 r9    # increment length
9013 // [44] 38:9
//         st r10 r7    # store r7 to buffer
7A73 // [45] 39:9
//         cp r7 r8     # check
87C3 // [46] 40:9
//         and r5 r8    #  if
8583 // [47] 41:9
//         xor r3 r8    #   carriage return
8363 // [48] 42:9
//         ifz jmp done # if true then done
00FD // [49] 43:9
//         addi -1 r2   # decrement buflen
2F13 // [50] 44:9
//         ifz jmp done # if zero then buffer full
00DD // [51] 45:9
// 
//         # read the high byte
//         rh r7        # read into higher r7
7E33 // [52] 48:9
//         wh r7        # echo
7A33 // [53] 49:9
//         addi 1 r9    # increment length
9013 // [54] 50:9
//         st r10 r7    # store r7 to buffer
7A73 // [55] 51:9
//         cp r7 r8     # check
87C3 // [56] 52:9
//         and r6 r8    #  if
8683 // [57] 53:9
//         xor r4 r8    #   carriage return
8463 // [58] 54:9
//         ifz jmp done # if true then done
005D // [59] 55:9
//         addi -1 r2   # decrement buflen
2F13 // [60] 56:9
//         ifz jmp done # if zero then buffer full
003D // [61] 57:9
// 
//         addi 1 r10   # increment buffer pointer
A013 // [62] 59:9
//         jmp loop     # 
FEBF // [63] 60:9
//     done:            # 
//     cp r9 r2 ret     # 
29C7 // [64] 62:5
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
// endfunc
// 
// print: func # r1: strptr, r2: strlen   clobbers: r1, r3, r4
//     ldi 0xfffe r3        
3033 // [80] 66:5
FFFE // [81] 66:5
//     and r2 r3            # get number of words containing 2 characters each
3283 // [82] 67:5
//     ifz jmp done         # if 0 then just one character
008D // [83] 68:5
//     shf 1 r3             # divide even length by 2
30E3 // [84] 69:5
//     loop:            
//         ld r1 r4     
4153 // [85] 71:9
//         wl r4        
4233 // [86] 72:9
//         wh r4         
4A33 // [87] 73:9
//         addi 1 r1     
1013 // [88] 74:9
//         addi -1 r3    
3F13 // [89] 75:9
//         ifp jmp loop  
FFBC // [90] 76:9
//     done:                
//     addi 1 r3            # reusing r3 which is now 0
3013 // [91] 78:5
//     and r2 r3            # find out if there is one more character in next word
3283 // [92] 79:5
//     ifz cp r3 r3  ret    # nop and return if no trailing character
33C5 // [93] 80:5
//     ld r1 r4             # write the
4153 // [94] 81:5
//     wl r4  ret           #   last character
4237 // [95] 82:5
// endfunc
// 
// print_hex: func # r1: number   clobbers: r2 r3 r4 r5 r6 r7
//     ldi 0x0f r2    # bit mask
2033 // [96] 86:5
000F // [97] 86:5
//     ldi 10 r3      # constant 10 for compare
3033 // [98] 87:5
000A // [99] 87:5
//     ldi 0x30 r4    # bits to 'or' to map number to ascii 0-9
4033 // [100] 88:5
0030 // [101] 88:5
//     ldi 0x41 r5    # ascii 'A'
5033 // [102] 89:5
0041 // [103] 89:5
// 
//     # bits 15:12
//     cp r1 r7           # don't clobber r1
71C3 // [104] 92:5
//     shf 4 r7           # shift to
73E3 // [105] 93:5
//     shf 8 r7           #   lowest nibble
77E3 // [106] 94:5
//     cp r7 r6           # 
67C3 // [107] 95:5
//     sub r3 r6          # compare with 10
6323 // [108] 96:5
//     ifp jmp letter4    # if r6 > r3
005C // [109] 97:5
//     ifz jmp letter4    # if r6 == r3
004D // [110] 98:5
//         or r4 r7       # nibble below 10, 'or' 0x30 to get ascii digit 0-9
7443 // [111] 99:9
//         wl r7          # write ascii 0-9
7233 // [112] 100:9
//         jmp hex3       # next nibble
003F // [113] 101:9
//     letter4:           # nibble 10 or above
//     add r5 r6          # 'A' + r6
6503 // [114] 103:5
//     wl r6              # write ascii a-f
6233 // [115] 104:5
// 
//     # bits 11:8
//     hex3:
//     cp r1 r7           # don't clobber r1
71C3 // [116] 108:5
//     shf 8 r7           # shift to lowest nibble
77E3 // [117] 109:5
//     and r2 r7          # bit mask lowest nibble
7283 // [118] 110:5
//     cp r7 r6           # compare with
67C3 // [119] 111:5
//     sub r3 r6          #   10
6323 // [120] 112:5
//     ifp jmp letter3    # if greater
005C // [121] 113:5
//     ifz jmp letter3    # if equal
004D // [122] 114:5
//         or r4 r7       
7443 // [123] 115:9
//         wl r7
7233 // [124] 116:9
//         jmp hex2
003F // [125] 117:9
//     letter3:            
//     add r5 r6          
6503 // [126] 119:5
//     wl r6              
6233 // [127] 120:5
// 
//     # bits 7:4
//     hex2:
//     cp r1 r7           
71C3 // [128] 124:5
//     shf 4 r7           
73E3 // [129] 125:5
//     and r2 r7
7283 // [130] 126:5
//     cp r7 r6           
67C3 // [131] 127:5
//     sub r3 r6          
6323 // [132] 128:5
//     ifp jmp letter2    
005C // [133] 129:5
//     ifz jmp letter2    
004D // [134] 130:5
//         or r4 r7       
7443 // [135] 131:9
//         wl r7
7233 // [136] 132:9
//         jmp hex1
003F // [137] 133:9
//     letter2:           
//     add r5 r6          
6503 // [138] 135:5
//     wl r6              
6233 // [139] 136:5
// 
//     # bits 3:0
//     hex1:
//     cp r1 r7           
71C3 // [140] 140:5
//     and r2 r7
7283 // [141] 141:5
//     cp r7 r6           
67C3 // [142] 142:5
//     sub r3 r6          
6323 // [143] 143:5
//     ifp jmp letter1    
004C // [144] 144:5
//     ifz jmp letter1    
003D // [145] 145:5
//         or r4 r7       
7443 // [146] 146:9
//         wl r7  ret
7237 // [147] 147:9
//     letter1:          
//     add r5 r6         
6503 // [148] 149:5
//     wl r6  ret
6237 // [149] 150:5
// 
// endfunc
// 
// # ----------------------------------------------------------------------
// hello.len: 6
0006 // [150] 155:-1
// hello.buf:
//     0x4548 # 'EH'
4548 // [151] 157:5
//     0x4c4c # 'LL'
4C4C // [152] 158:5
//     0x204f # ' O'
204F // [153] 159:5
// 
// input.len: 64
0040 // [154] 161:-2
// input.buf:
//     0 
0000 // [155] 163:5
// 0 
0000 // [156] 163:7
// 0 
0000 // [157] 163:9
// 0 
0000 // [158] 163:11
// 0 
0000 // [159] 163:13
// 0 
0000 // [160] 163:15
// 0 
0000 // [161] 163:17
// 0
0000 // [162] 163:19
//     0 
0000 // [163] 164:5
// 0 
0000 // [164] 164:7
// 0 
0000 // [165] 164:9
// 0 
0000 // [166] 164:11
// 0 
0000 // [167] 164:13
// 0 
0000 // [168] 164:15
// 0 
0000 // [169] 164:17
// 0
0000 // [170] 164:19
//     0 
0000 // [171] 165:5
// 0 
0000 // [172] 165:7
// 0 
0000 // [173] 165:9
// 0 
0000 // [174] 165:11
// 0 
0000 // [175] 165:13
// 0 
0000 // [176] 165:15
// 0 
0000 // [177] 165:17
// 0
0000 // [178] 165:19
//     0 
0000 // [179] 166:5
// 0 
0000 // [180] 166:7
// 0 
0000 // [181] 166:9
// 0 
0000 // [182] 166:11
// 0 
0000 // [183] 166:13
// 0 
0000 // [184] 166:15
// 0 
0000 // [185] 166:17
// 0
0000 // [186] 166:19
// 
//     0 
0000 // [187] 168:5
// 0 
0000 // [188] 168:7
// 0 
0000 // [189] 168:9
// 0 
0000 // [190] 168:11
// 0 
0000 // [191] 168:13
// 0 
0000 // [192] 168:15
// 0 
0000 // [193] 168:17
// 0
0000 // [194] 168:19
//     0 
0000 // [195] 169:5
// 0 
0000 // [196] 169:7
// 0 
0000 // [197] 169:9
// 0 
0000 // [198] 169:11
// 0 
0000 // [199] 169:13
// 0 
0000 // [200] 169:15
// 0 
0000 // [201] 169:17
// 0
0000 // [202] 169:19
//     0 
0000 // [203] 170:5
// 0 
0000 // [204] 170:7
// 0 
0000 // [205] 170:9
// 0 
0000 // [206] 170:11
// 0 
0000 // [207] 170:13
// 0 
0000 // [208] 170:15
// 0 
0000 // [209] 170:17
// 0
0000 // [210] 170:19
//     0 
0000 // [211] 171:5
// 0 
0000 // [212] 171:7
// 0 
0000 // [213] 171:9
// 0 
0000 // [214] 171:11
// 0 
0000 // [215] 171:13
// 0 
0000 // [216] 171:15
// 0 
0000 // [217] 171:17
// 0
0000 // [218] 171:19
//     

