// ledi 0b1000
8F33 // [0] 1:1
// xor r15 r15          # zero r15
FF63 // [1] 2:1
// loop:
//     ldi hello.len r2 # hello
2033 // [2] 4:5
0096 // [3] 4:5
//     ld r2 r2         # load len
2253 // [4] 5:5
//     ldi hello.buf r1 # buffer 
1033 // [5] 6:5
0097 // [6] 6:5
//     call print       #
005B // [7] 7:5
//     
//     addi 1 r15
F013 // [8] 9:5
//     cp r15 r1        # print r15 as hex
1FC3 // [9] 10:5
//     call print_hex   #
006B // [10] 11:5
//     ldi 0x20 r1      # space
1033 // [11] 12:5
0020 // [12] 12:5
//     wl r1            #
1233 // [13] 13:5
//     
//     ldi input.buf r1 # input buffer
1033 // [14] 15:5
009B // [15] 15:5
//     ldi input.len r2 # buffer size address
2033 // [16] 16:5
009A // [17] 16:5
//     ld r2 r2         # buffer size
2253 // [18] 17:5
//     call input       # input (buffer:r1, buflen:r2)
002B // [19] 18:5
//     ldi 0xa r3       # new line
3033 // [20] 19:5
000A // [21] 19:5
//     wl r3            #  send
3233 // [22] 20:5
//     call print       # print (buffer:r1, buflen:r2) 'input' sets buflen 
005B // [23] 21:5
//     ldi 0xa r3       # new line
3033 // [24] 22:5
000A // [25] 22:5
//     wl r3            #  send
3233 // [26] 23:5
//     jmp loop
FE7F // [27] 24:5
0000
0000
0000
0000
// 
// input: func # r1: bufptr, r2: buflen  clobbers: r2, r3, r4, r5, r6, r7, r8, r9, r10
//     ldi 0x000d r3
3033 // [32] 27:5
000D // [33] 27:5
//     ldi 0x0d00 r4
4033 // [34] 28:5
0D00 // [35] 28:5
//     ldi 0x00ff r5
5033 // [36] 29:5
00FF // [37] 29:5
//     ldi 0xff00 r6
6033 // [38] 30:5
FF00 // [39] 30:5
//     cp r1 r10
A1C3 // [40] 31:5
//     xor r9 r9
9963 // [41] 32:5
//     loop:
//         # read the low byte
//         rl r7        # read into lower r7
7633 // [42] 35:9
//         wl r7        # echo
7233 // [43] 36:9
//         addi 1 r9    # increment length
9013 // [44] 37:9
//         st r10 r7    # store r7 to buffer
7A73 // [45] 38:9
//         cp r7 r8     # check
87C3 // [46] 39:9
//         and r5 r8    #  if
8583 // [47] 40:9
//         xor r3 r8    #   carriage return
8363 // [48] 41:9
//         ifz jmp done # if true then done
00FD // [49] 42:9
//         addi -1 r2   # decrement buflen
2F13 // [50] 43:9
//         ifz jmp done # if zero then buffer full
00DD // [51] 44:9
// 
//         # read the high byte
//         rh r7        # read into higher r7
7E33 // [52] 47:9
//         wh r7        # echo
7A33 // [53] 48:9
//         addi 1 r9    # increment length
9013 // [54] 49:9
//         st r10 r7    # store r7 to buffer
7A73 // [55] 50:9
//         cp r7 r8     # check
87C3 // [56] 51:9
//         and r6 r8    #  if
8683 // [57] 52:9
//         xor r4 r8    #   carriage return
8463 // [58] 53:9
//         ifz jmp done # if true then done
005D // [59] 54:9
//         addi -1 r2   # decrement buflen
2F13 // [60] 55:9
//         ifz jmp done # if zero then buffer full
003D // [61] 56:9
// 
//         addi 1 r10   # increment buffer pointer
A013 // [62] 58:9
//         jmp loop     # 
FEBF // [63] 59:9
//     done:            # 
//     cp r9 r2 ret     # 
29C7 // [64] 61:5
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
// endfunc
// 
// print: func # r1: strptr, r2: strlen   clobbers: r1, r3, r4
//     ldi 0xfffe r3        
3033 // [80] 65:5
FFFE // [81] 65:5
//     and r2 r3            # get number of words containing 2 characters each
3283 // [82] 66:5
//     ifz jmp done         # if 0 then just one character
008D // [83] 67:5
//     shf 1 r3             # divide even length by 2
30E3 // [84] 68:5
//     loop:            
//         ld r1 r4     
4153 // [85] 70:9
//         wl r4        
4233 // [86] 71:9
//         wh r4         
4A33 // [87] 72:9
//         addi 1 r1     
1013 // [88] 73:9
//         addi -1 r3    
3F13 // [89] 74:9
//         ifp jmp loop  
FFBC // [90] 75:9
//     done:                
//     addi 1 r3            # reusing r3 which is now 0
3013 // [91] 77:5
//     and r2 r3            # find out if there is one more character in next word
3283 // [92] 78:5
//     ifz cp r3 r3  ret    # nop and return if no trailing character
33C5 // [93] 79:5
//     ld r1 r4             # write the
4153 // [94] 80:5
//     wl r4  ret           #   last character
4237 // [95] 81:5
// endfunc
// 
// print_hex: func # r1: number   clobbers: r2 r3 r4 r5 r6 r7
//     ldi 0x0f r2    # bit mask
2033 // [96] 85:5
000F // [97] 85:5
//     ldi 10 r3      # constant 10 for compare
3033 // [98] 86:5
000A // [99] 86:5
//     ldi 0x30 r4    # bits to 'or' to map number to ascii 0-9
4033 // [100] 87:5
0030 // [101] 87:5
//     ldi 0x41 r5    # ascii 'A'
5033 // [102] 88:5
0041 // [103] 88:5
// 
//     # bits 15:12
//     cp r1 r7           # don't clobber r1
71C3 // [104] 91:5
//     shf 4 r7           # shift to
73E3 // [105] 92:5
//     shf 8 r7           #   lowest nibble
77E3 // [106] 93:5
//     cp r7 r6           # 
67C3 // [107] 94:5
//     sub r3 r6          # compare with 10
6323 // [108] 95:5
//     ifp jmp letter4    # if r6 > r3
005C // [109] 96:5
//     ifz jmp letter4    # if r6 == r3
004D // [110] 97:5
//         or r4 r7       # nibble below 10, 'or' 0x30 to get ascii digit 0-9
7443 // [111] 98:9
//         wl r7          # write ascii 0-9
7233 // [112] 99:9
//         jmp hex3       # next nibble
003F // [113] 100:9
//     letter4:           # nibble 10 or above
//     add r5 r6          # 'A' + r6
6503 // [114] 102:5
//     wl r6              # write ascii a-f
6233 // [115] 103:5
// 
//     # bits 11:8
//     hex3:
//     cp r1 r7           # don't clobber r1
71C3 // [116] 107:5
//     shf 8 r7           # shift to lowest nibble
77E3 // [117] 108:5
//     and r2 r7          # bit mask lowest nibble
7283 // [118] 109:5
//     cp r7 r6           # compare with
67C3 // [119] 110:5
//     sub r3 r6          #   10
6323 // [120] 111:5
//     ifp jmp letter3    # if greater
005C // [121] 112:5
//     ifz jmp letter3    # if equal
004D // [122] 113:5
//         or r4 r7       
7443 // [123] 114:9
//         wl r7
7233 // [124] 115:9
//         jmp hex2
003F // [125] 116:9
//     letter3:            
//     add r5 r6          
6503 // [126] 118:5
//     wl r6              
6233 // [127] 119:5
// 
//     # bits 7:4
//     hex2:
//     cp r1 r7           
71C3 // [128] 123:5
//     shf 4 r7           
73E3 // [129] 124:5
//     and r2 r7
7283 // [130] 125:5
//     cp r7 r6           
67C3 // [131] 126:5
//     sub r3 r6          
6323 // [132] 127:5
//     ifp jmp letter2    
005C // [133] 128:5
//     ifz jmp letter2    
004D // [134] 129:5
//         or r4 r7       
7443 // [135] 130:9
//         wl r7
7233 // [136] 131:9
//         jmp hex1
003F // [137] 132:9
//     letter2:           
//     add r5 r6          
6503 // [138] 134:5
//     wl r6              
6233 // [139] 135:5
// 
//     # bits 3:0
//     hex1:
//     cp r1 r7           
71C3 // [140] 139:5
//     and r2 r7
7283 // [141] 140:5
//     cp r7 r6           
67C3 // [142] 141:5
//     sub r3 r6          
6323 // [143] 142:5
//     ifp jmp letter1    
004C // [144] 143:5
//     ifz jmp letter1    
003D // [145] 144:5
//         or r4 r7       
7443 // [146] 145:9
//         wl r7  ret
7237 // [147] 146:9
//     letter1:          
//     add r5 r6         
6503 // [148] 148:5
//     wl r6  ret
6237 // [149] 149:5
// 
// endfunc
// 
// # ----------------------------------------------------------------------
// hello.len: 6
0006 // [150] 154:-1
// hello.buf:
//     0x4548 # 'EH'
4548 // [151] 156:5
//     0x4c4c # 'LL'
4C4C // [152] 157:5
//     0x204f # ' O'
204F // [153] 158:5
// 
// input.len: 64
0040 // [154] 160:-2
// input.buf:
//     0 
0000 // [155] 162:5
// 0 
0000 // [156] 162:7
// 0 
0000 // [157] 162:9
// 0 
0000 // [158] 162:11
// 0 
0000 // [159] 162:13
// 0 
0000 // [160] 162:15
// 0 
0000 // [161] 162:17
// 0
0000 // [162] 162:19
//     0 
0000 // [163] 163:5
// 0 
0000 // [164] 163:7
// 0 
0000 // [165] 163:9
// 0 
0000 // [166] 163:11
// 0 
0000 // [167] 163:13
// 0 
0000 // [168] 163:15
// 0 
0000 // [169] 163:17
// 0
0000 // [170] 163:19
//     0 
0000 // [171] 164:5
// 0 
0000 // [172] 164:7
// 0 
0000 // [173] 164:9
// 0 
0000 // [174] 164:11
// 0 
0000 // [175] 164:13
// 0 
0000 // [176] 164:15
// 0 
0000 // [177] 164:17
// 0
0000 // [178] 164:19
//     0 
0000 // [179] 165:5
// 0 
0000 // [180] 165:7
// 0 
0000 // [181] 165:9
// 0 
0000 // [182] 165:11
// 0 
0000 // [183] 165:13
// 0 
0000 // [184] 165:15
// 0 
0000 // [185] 165:17
// 0
0000 // [186] 165:19
// 
//     0 
0000 // [187] 167:5
// 0 
0000 // [188] 167:7
// 0 
0000 // [189] 167:9
// 0 
0000 // [190] 167:11
// 0 
0000 // [191] 167:13
// 0 
0000 // [192] 167:15
// 0 
0000 // [193] 167:17
// 0
0000 // [194] 167:19
//     0 
0000 // [195] 168:5
// 0 
0000 // [196] 168:7
// 0 
0000 // [197] 168:9
// 0 
0000 // [198] 168:11
// 0 
0000 // [199] 168:13
// 0 
0000 // [200] 168:15
// 0 
0000 // [201] 168:17
// 0
0000 // [202] 168:19
//     0 
0000 // [203] 169:5
// 0 
0000 // [204] 169:7
// 0 
0000 // [205] 169:9
// 0 
0000 // [206] 169:11
// 0 
0000 // [207] 169:13
// 0 
0000 // [208] 169:15
// 0 
0000 // [209] 169:17
// 0
0000 // [210] 169:19
//     0 
0000 // [211] 170:5
// 0 
0000 // [212] 170:7
// 0 
0000 // [213] 170:9
// 0 
0000 // [214] 170:11
// 0 
0000 // [215] 170:13
// 0 
0000 // [216] 170:15
// 0 
0000 // [217] 170:17
// 0
0000 // [218] 170:19
//     

